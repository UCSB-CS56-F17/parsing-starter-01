<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cs56Parser</a> &gt; <a href="index.source.html" class="el_package">edu.ucsb.cs56.pconrad.parsing.parser</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">package edu.ucsb.cs56.pconrad.parsing.parser;

import edu.ucsb.cs56.pconrad.parsing.syntax.*;
import edu.ucsb.cs56.pconrad.parsing.tokenizer.*;

import java.util.*;

/**
 * Parses a sequence of tokens into an AST.
 * This is specific to our arithmetic expression language.
 */
public class Parser {
    // BEGIN CONSTANTS


<span class="fc" id="L16">    public static final Token LEFT_PAREN_TOKEN = new LParenToken();</span>
<span class="fc" id="L17">    public static final Token RIGHT_PAREN_TOKEN = new RParenToken();</span>
<span class="fc" id="L18">    public static final Token PLUS_TOKEN = new PlusToken();</span>
<span class="fc" id="L19">    public static final Token MINUS_TOKEN = new MinusToken();</span>
<span class="fc" id="L20">    public static final Token TIMES_TOKEN = new TimesToken();</span>
<span class="fc" id="L21">    public static final Token DIV_TOKEN = new DivideToken();</span>
    // END CONSTANTS
    
    // BEGIN INSTANCE VARIABLES
    private final ArrayList&lt;Token&gt; input;
    // END INSTANCE VARIABLES

    /**
     * @param input The tokens to parse.  This is intentionally an &lt;code&gt;ArrayList&lt;/code&gt;
     *              to guarantee constant-time random access, which is necessary
     *              for performance.
     */
<span class="fc" id="L33">    public Parser(final ArrayList&lt;Token&gt; input) {</span>
<span class="fc" id="L34">	this.input = input;</span>
<span class="fc" id="L35">    }</span>



    /**
     * Parses a &lt;code&gt;primary&lt;/code&gt; expression, as per our arithmetic expression grammar.
     *
     * @param pos The position where to start parsing from
     */
    

    private ParseResult&lt;AST&gt; parsePrimary(final int pos) throws ParserException {
<span class="fc" id="L47">	final Token firstToken = tokenAt(pos);</span>
	
<span class="fc bfc" id="L49" title="All 2 branches covered.">	if (firstToken.equals(LEFT_PAREN_TOKEN)) {</span>
<span class="fc" id="L50">	    final ParseResult&lt;AST&gt; nestedExp = parseExpression(pos + 1);</span>
<span class="fc" id="L51">	    final int nextPos = nestedExp.getNextPos();</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">	    if (tokenAt(nextPos).equals(RIGHT_PAREN_TOKEN)) {</span>
<span class="fc" id="L53">		return new ParseResult&lt;AST&gt;(nestedExp.getResult(),</span>
					    nextPos + 1);
	    } else {
<span class="fc" id="L56">		throw new ParserException(&quot;Expected ')'&quot;);</span>
	    }
<span class="fc bfc" id="L58" title="All 2 branches covered.">	} else if (firstToken.equals(MINUS_TOKEN)) {</span>
<span class="fc" id="L59">	    final ParseResult&lt;AST&gt; nestedExp = parsePrimary(pos + 1);</span>
<span class="fc" id="L60">	    return new ParseResult&lt;AST&gt;(new UnaryMinus(nestedExp.getResult()),</span>
<span class="fc" id="L61">					nestedExp.getNextPos());</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">	} else if (firstToken instanceof IntToken) {</span>
<span class="fc" id="L63">	    return new ParseResult&lt;AST&gt;(new Literal(((IntToken)firstToken).getValue()),</span>
					pos + 1);
	} else {
<span class="fc" id="L66">	    throw new ParserException(&quot;Expected primary expression; got: &quot; +</span>
<span class="fc" id="L67">				      firstToken.toString());</span>
	}
    }

    
    private ParseResult&lt;Operator&gt; parsePlusMinus(final int pos) throws ParserException {
<span class="fc" id="L73">	final Token tokenHere = tokenAt(pos);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">	if (tokenHere.equals(PLUS_TOKEN)) {</span>
<span class="fc" id="L75">	    return new ParseResult&lt;Operator&gt;(Plus.PLUS, pos + 1);</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">	} else if (tokenHere.equals(MINUS_TOKEN)) {</span>
<span class="fc" id="L77">	    return new ParseResult&lt;Operator&gt;(Minus.MINUS, pos + 1);</span>
	} else {
<span class="fc" id="L79">	    throw new ParserException(&quot;Expected + or - operator &quot;);</span>
	}
	
    }
    
    private ParseResult&lt;Operator&gt; parseTimesDiv(final int pos) throws ParserException {
<span class="fc" id="L85">	final Token tokenHere = tokenAt(pos);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">	if (tokenHere.equals(TIMES_TOKEN)) {</span>
<span class="fc" id="L87">	    return new ParseResult&lt;Operator&gt;(Times.TIMES, pos + 1);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">	} else if (tokenHere.equals(DIV_TOKEN)) {</span>
<span class="fc" id="L89">	    return new ParseResult&lt;Operator&gt;(Div.DIV, pos + 1);</span>
	} else {
<span class="fc" id="L91">	    throw new ParserException(&quot;Expected * or / operator &quot;);</span>
	}
    }
    
    // BEGIN CODE FOR MULTIPLICATIVE AND ADDITIVE EXPRESSIONS
    /**
     * As with &lt;code&gt;PrimaryTokenVisitor&lt;/code&gt;, this is defined as an inner class
     * to get access to all the methods on &lt;code&gt;Parser&lt;/code&gt;, without (innapropriately)
     * making those methods &lt;code&gt;public&lt;/code&gt;.
     */
<span class="fc" id="L101">    private class ParseAdditive extends ParseAdditiveOrMultiplicative {</span>

	public ParseResult&lt;AST&gt; parseBase(final int pos) throws ParserException {
<span class="fc" id="L104">	    return parseMultiplicativeExpression(pos);</span>
	}
	
	public ParseResult&lt;Operator&gt; parseOp(final int pos) throws ParserException {
<span class="fc" id="L108">	    return parsePlusMinus(pos);</span>
	}
    }

    /**
     * As with &lt;code&gt;PrimaryTokenVisitor&lt;/code&gt;, this is defined as an inner class
     * to get access to all the methods on &lt;code&gt;Parser&lt;/code&gt;, without (innapropriately)
     * making those methods &lt;code&gt;public&lt;/code&gt;.
     */
<span class="fc" id="L117">    private class ParseMultiplicative extends ParseAdditiveOrMultiplicative {</span>
	public ParseResult&lt;AST&gt; parseBase(final int pos) throws ParserException {
<span class="fc" id="L119">	    return parsePrimary(pos);</span>
	}
	public ParseResult&lt;Operator&gt; parseOp(final int pos) throws ParserException {
<span class="fc" id="L122">	    return parseTimesDiv(pos);</span>
	}
    }

    // because the above two classes hold no state and don't have useful
    // constructors, we can simply allocate these ahead of time and use
    // them throughout
    
<span class="fc" id="L130">    private final ParseAdditive PARSE_ADDITIVE = new ParseAdditive();</span>
<span class="fc" id="L131">    private final ParseMultiplicative PARSE_MULTIPLICATIVE = new ParseMultiplicative();</span>

    private ParseResult&lt;AST&gt; parseMultiplicativeExpression(final int pos)
	throws ParserException {
<span class="fc" id="L135">	return PARSE_MULTIPLICATIVE.parseExp(pos);</span>
    }

    private ParseResult&lt;AST&gt; parseAdditiveExpression(final int pos)
	throws ParserException {
<span class="fc" id="L140">	return PARSE_ADDITIVE.parseExp(pos);</span>
    }
    // END CODE FOR MULIPLICATIVE AND ADDITIVE EXPRESSIONS
    
    private ParseResult&lt;AST&gt; parseExpression(final int pos) throws ParserException {
<span class="fc" id="L145">	return parseAdditiveExpression(pos);</span>
    }

    /**
     * Used to get access to underlying tokens.
     * This should &lt;b&gt;always&lt;/b&gt; be used instead of directly accessing the underlying
     * list of tokens.  While running off of the end of a list usually indicates a bug,
     * when it comes to parsing running off the end of the list simply means the input
     * wasn't valid (which isn't a bug, but an error in user input).
     *
     * @param pos The position where to get the token
     * @return The token at &lt;code&gt;pos&lt;/code&gt;
     * @throws ParserException if &lt;code&gt;pos&lt;/code&gt; is out of range; that is, there
     *         is no token at &lt;code&gt;pos&lt;/code&gt;.
     */
     Token tokenAt(final int pos) throws ParserException {
<span class="fc bfc" id="L161" title="All 4 branches covered.">	if (pos &lt; 0 || pos &gt;= input.size()) {</span>
<span class="fc" id="L162">	    throw new ParserException(&quot;Attempted to get token out of position&quot;);</span>
	} else {
<span class="fc" id="L164">	    return input.get(pos);</span>
	}
    }

    /**
     * Parses the list of tokens provided in the constructor.
     *
     * @return The AST resulting from parsing
     * @throws ParserException If the tokens could not be parsed, e.g., with the
     *         input &lt;code&gt;)3(&lt;/code&gt;.
     */
    public AST parse() throws ParserException {
<span class="fc" id="L176">	final ParseResult&lt;AST&gt; rawResult = parseExpression(0);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">	if (rawResult.getNextPos() != input.size()) {</span>
<span class="fc" id="L178">	    throw new ParserException(&quot;Extra tokens at the end&quot;);</span>
	} else {
<span class="fc" id="L180">	    return rawResult.getResult();</span>
	}
    }
} // Parser
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>